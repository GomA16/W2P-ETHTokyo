{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"16334665462979284220","abi":{"parameters":[{"name":"private","type":{"kind":"array","length":2144,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"loan_state","type":{"kind":"array","length":32,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"public"}],"return_type":null,"error_types":{"5795655218219125583":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"}}},"bytecode":"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","debug_symbols":"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nEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzKyaScTMrJpJxMysmknEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJxMycmUnEzJyZScTMnJlJzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJyTw5mScn8+RknpzMk5N5cjJPTubJybxPJ7OfD7+8+dv/UtL7hDJfT6unbxl+PQVPh6fLU/JUPD2euHG4cbhxuXG5cblxufEtym//C1/vU858/TVuXG5cblxuJDeSG8mN5Eby+0huJDeSG8mN5EZxo7jxLdPvv+biRnGjuFHcKG4UN4objxuPG4/fx+PG48bjxuPG48bjxuPGt3C//5qbG82N5kZzo7nR3GhuNDeaG8PvY7gx3BhuDDeGG8ON4ca3lL//mocby43lxnJjubHcWG4sN5Yby+9jdeOT3nw9BU+Hp8tT8lQ8va9f86fA+fprwxM3ghvBjeBGcCO4EdyIxxM36PzQ+aHzQ+eHzg+df5Kc779mOj90fuj80Pmh80Pnh84PnR86/8Q5X0/coPND54fOD50fOj90/ol0vv+a6fzQ+aHzQ+eHzg+dHzo/dH7o/JPrfD1xg84PnR86P3R+6PzQ+Sfb+f5rpvND54fOD50fOj90fuj80Pmh80/A8/XEDTo/dH7o/ND5ofND55+Q5/uvmc4PnR86P3R+6PzQ+aHzQ+eHzj9Jz9cTN+j80Pmh80Pnh84PnX/Snu+/Zjo/dH7o/NL5pfNL55fOL51fOv9EPl9PzdPwxA06v3R+6fzS+Sf2+fw1Xzq/dH7p/NL5pfNL55fOL51fOr98P790fun80vml80vnl84vnX/yn++/Zjq/dH7p/NL5pfNL55fOL51fOr98P790fun80vml80vnl84vnX+CoO+/Zjq/dH7p/NL5pfNL55fOL51fOr98P790fun80vml80vnl84vnX8Soe+/Zjq/dH7p/NL5pfNL55fOL51fOr98P790fun80vml80vnn2To+6/vs/P9fHo8NU/D0+rps/PvT8HT4enylDxxY7mx3FhurG58EqKvp+Dp8HR5Sp6Kp8dT8zQ8cSO4EdwIbgQ3ghvBjeBGcCO4Edw43DjcONw43Djc+Nb5t//x2veJi76emqfhafX0rfOvp+Dp8HR5Sp64cbnxrfPzPp+4cbmR3EhufOv8+1ckN5IbyY3kRnIjuZHcKG4UN4obxY3iRnGjuFHcKG4UNx43HjceNx43HjceNx43HjceNx43mhvNjeZGc6O50dxobjQ3mhvNjeHGcGO4MdwYbgw3hhvDjeHGcGO5sdxYbiw3lhvLjeXGcmO5sbrxyZS+noIn3fiUSl9/LXkqnh5PzVcMf40bwY3gRnAjuBHcCG4EN4IbwY3gxuHG4cbhxuHG4QadF51/Cqavr+AGnRedF51/MqbvX0HnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF55/66euJG3RedF50/kmgvp64QeefCur7r4DOPx3U1xM36PyTQn1+xaPzTwz19XR5Sp6Kr3j8teZpeOJGcIPOP1nU1xM36PxTRn19BTeCG3T+6PyTR33/Cjr/BFJfT9yg808j9fUV3OD7+aPzR+efUOr7V9D54/v5o/NH559a6usruHG5QeePzj/J1PevoPNPNPX1xA06/3RTX1/BjeQGnT86/8RT37+Czj/51NcTN+j8U1B9fQU3iht0/uj8k1F9/wo6/4RUX0/coPNPS/X1Fdx43KDzR+efoOr7V9D5J6n6euIGnX+qqq+v4EZzg84fnX/Squ9fQeefuOrriRt0/umrvr6CG3T+6PzR+Sey+v4VdP7o/NH5o/NH54/OH50/On903nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedP7pss75fDo8cYPOm+/nTedN503nTefN9/Om86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofPh+/nw/XzofOh8+H4+dD50PnQ+dD58Px86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86Xzr/dGOf3zU+4djX0+VflzwVT4+n5ml44gb///nS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+dL50vnS+arz/lDn/aHv5/2h7+f9oc77Q533h76f94c67w913h/qvD8+uBHcCG4EN4IbwY3gRnAjuBHcCG4cbhxuHG4cbhxuHG4cbhxuHG4cblxuXG5cblxuXG5cblxuXG5cblxuJDeSG8mN5EZyI7mR3EhuJDeSG8WN4kZxo7hR3ChuFDeKG8WN4sbjxvv6/tGfsO3riRuPG/rv4frjceNx43HjcUP/PVx/NL+P5vfR3GhuNL+P5kZzo7nR3Bh+H8ON4cZwY7gx3BhuDDeGG8ON5cZyY7mx3FhuLDeWG8uN5QadB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB53H48bjBp0HncfjBp0HnQedB51Hc4POg86DzoPOg86DzoPOg86DzoPOg86DzoPOg86DzoPOg86DzoPOg86DzoPOg86DzoPOg86DzoPOg84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmnh/v8rvHp4b6euEHnR5+r9aHzQ+eHzg+dH32u1ofOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/NL5pfNL55fOL51fOr90fun80vml80vnl84vnV86v3R+6fzS+aXzS+eXzi+dX76fX76fXzq/dH75fn7p/NL5pfNL55fv55fOL51fOr90fun80vml80vnl84vnV86v3R+6fzS+aXzS+eXzi+dXzq/dH7p/NL5pfNL55fOL51fOr90fun80vml80vnl84vnV86v3R+6fzS+aXzS+eXzi+dXzq/dH7p/NL5pfNL55fOL51/erjP7xqfHu7riRt0fvX5eV86v3R+6fzS+dXn533p/NL5pfNL55fOL51fOr90fuk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpHA/XeLjGwzUerpPO8XCNh2s8XOPhOukcD9dJ53i4xsN10jkerpPO8XCNh+ukczxcJ53j4RoP10nneLhOOsfDNR6uk87xcJ10jodrPFwnnePhOukcD9d4uE46x8N10jkervFwnXSOh+ukczxc4+E66RwP10nneLjGw3XSOR6uk+/neLjGw3Xy/RwP10nneLjGw3Xy/RwP10nneLjGw3XSOR6uk87xcI2H66JzPFwXnePhGg/XRed4uC46x8M1Hq6LzvFwXXSOh2s8XBed4+G66BwP13i4LjrHw3XROR6u8XBddI6H66JzPFzj4broHA/XRed4uMbDddE5Hq6LzvFwjYfrovPS5+dd+vy88XCNh2s8XOPhuugcD9d4uMbDNR6ui87xcI2H66JzPFwXnePhGg/XRed4uC46x8M1Hq6LzvFwXXSOh2s8XBed4+G66BwP13i4LjrHw3XROR6u8XBddI6H66JzPFzj4broHA/XeLjG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8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XAb+vx8Q5+fLx5u8XAb+vx88XCLh1s83OLhNvT5+eLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwy8+HW34+3OLhFg+3/Hy4xcMtHm7xcIuHW34+3OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcHv1+flefX6+eLjFw+3V5+eLh1s83OLhFg+3V5+fLx5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3/Hy45efDLR5u8XDLz4dbPNzi4RYPt3i45efDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt6nPzzf1+fni4RYPt/zvpS4ebvFwi4dbPNzyv5e6eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzy8+GWnw+3eLjFwy0/H27xcIuHWzzc4uGWnw+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzcPn1+vk+fny8ebvFw+/T5+eLhFg+3eLjFw+3T5+eLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0/H275+XCLh1s83PLz4RYPt3i4xcMtHm75+XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcNt6/PzbX1+vni4xcNt6/PzxcMtHm7xcIuH29bn54uHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLT8fbvn5cIuHWzzc8vPhFg+3eLjFwy0ebvn5cIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFw+3y+fny+TkebvFwu3x+jodbPNzi4RYPt8vn53i4xcMtHm7xcIuHWzzc4uEWD7d4uMXDLR5u8XCLh1s83OLhFg+3eLjFwy0ebvFwi4dbPNzi4RYPt3i4xcMtHm7xcIuHWzzc8vPhlp8Pt3i4xcMtPx9u8XCLh1s83OLhlp8Pt3i4xcMtHm7xcIuHWzzc4uEWD7d4uPgAxH17DP/V48frx/Rj+cue/2r7cfzoa+Fr4Wvha+Fr4Wvha+Fr4Wvha+Frx9eOrx1fO752fO342vG142vH146vXV+7vnZ97fra9bXra9fXrq9dX7u+lr6Wvpa+lr6Wvpa+lr6Wvpa+lr5Wvla+Vr5Wvla+Vr5Wvla+Vr5WvvZ87fna87Xna8/Xnq89X3u+9nzt+Vr7Wvta+1r7Wvta+1r7Wvta+1r72vja+Nr42vja+Nr42vja+Nr42vja+tr62vra+tr62vra+tr62vqatyS8JaFP6b89Hj9e/2vTj+XH58f24/jR1/Rx/bfH8OPxo695S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXHW3L855LjP5ccb8nxlhz/ueR4S4635HhLjrfk+M8lx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXHW3K8Jcdbcrwlx1tyvCXn8f3tvONHX/OWnFd+9DVvyfGWHG/J6Q8/+vfmLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y25/nPJ9Z9Lrrfkekuu/1xyvSXXW3K9Jddbcv3nkustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLbnekustud6S6y253pLrLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSW5OH7W57jR1/zluQpP/qatyS9JektyfvhR//evCXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeU/l5T/XFLekvKWlP9cUt6S8paUt6S8JeU/l5S3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwlNXx/qzl+9DVvSU350de8JeUtKW9J7Ycf/XvzlpS3pLwl5S0pb0l5S8pbUt6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXnekucted6S5y153pLnLXn+c8nzn0uet+R5S57/XPK8Jc9b8rwlz1vy/OeS5y153pLnLXnekucted6S5y153pLnLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9JJ9/fOo8ffc1b0ll+9DVvSXtL2lvS9eFH/968Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4z+XjP9cMt6S8ZaM/1wy3pLxloy3ZLwl4z+XjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvSVrX7L2JestWW/J2pest2S9JestWW/J2pest2S9JestWW/JekvWW7LekvWWrLdkvSXrLVlvyXpL1luy3pL1lqy3ZL0l6y1Zb8l6S9Zbst6S9Zast2S9JestWW/JekvWW7LekvWWrLdkvSXrLVlvyXpL1luy3pL1lqy3ZL0l6y1Zb8l6S9Zbst6S9Zast2S9JestWW/JekvWW7LekvWWrLdkvSXrLVlvyXpL1luy3pL1lqy3ZL0l6y1Zb8l6S9Zbst6S9Zast2S9JestWW/JekvWW7LekvWWrLdkvSXrLVlvyXpL1luy3pL1lti9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1rfOBL4gNfEnavYfcaH/iSsHsNu9ewew271/jAl4Tda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvUZ4S8JbYvcadq8R3hK717B7DbvXsHuN8JbYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbdaxx8SRx8Sdi9ht1rHHxJ2L2G3WvYvYbdaxx8Sdi9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbdaxxvyfGW2L2G3Wscb4nda9i9ht1r2L3G8ZbYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda1x8SVx8Sdi9ht1rXHxJ2L2G3WvYvYbda1x8Sdi9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda6S3JL0ldq9h9xrpLbF7DbvXsHsNu9dIb4nda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9RuFLovAl8d299t9/98P//MPPP/7hn3/603/88E//+cs//Ne//fmPf/3xL3/++od//X//Xf/MP//8408//fhvv//3n//yxz/9y99+/tPvf/rLHz//ub//j7//fw==","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use keccak256::keccak256;\n\nfn main(private: [u8;2144], loan_state:pub [[u8;32];32]){\n    let current = keccak256(private, private.len());\n    let mut flag = false;\n    for i in 0..loan_state.len() {\n        if (current == loan_state[i]) {flag = true;}\n    }\n    assert(flag);\n}\n","path":"/Users/masanari/work/zk/W2P-ETHTokyo/contract/circuits/borrowCircuit/src/main.nr"},"52":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/Users/masanari/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}