{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"16757000395526976318","abi":{"parameters":[{"name":"loan_state","type":{"kind":"array","length":32,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"public"},{"name":"baseid","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"repaid_k1","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"unpaied_k1","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"UnpaiedEntry","fields":[{"name":"unpaied_loan_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"unpaied_amt","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}},"visibility":"private"},{"name":"k1","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"5795655218219125583":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"}}},"bytecode":"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","debug_symbols":"td3Rjm1Zca7bd6lrLrKPHjEiwq9ytIUwxhZSCSwMWzqyePdTlWtlC3wBx7usfeVB4ZmRq4rvzzSzafo/f/iX3/3zX/7t17//w7/+8T9++Kf/5z9/+Oc//f7HH3//b7/+8Y+//c2ff//HP/z0V//zr7/64etf/vrPf/rd7376Sz/8zb//06v+/Td/+t0f/vzDP/3hLz/++Ksf/vdvfvzL5//Sf/z7b/7w+T///Js//fTvfvzqh9/94V9++p8/fcF//f2Pv/v56a+/2ld//P2X3pvfX3wjvDz/+6/v/v76+Pj4Ba/P5+t+3v6fvT7rF7z+zfn++ree/9nr+5fcr/76h1edv+D1/fF1v//+P7/++68/b8f3L3Dq+Zt/gs9//yvU7Fc4v+grvP/Tr1B9fYV5f8FXeOp9v3+Fpyp+yVfo53x9hb7z977CiX/wH4bz9c+i/uYLnPlvfwujxmd+2d+G/Qr349Yv+gpVvoe//Y/0f/sr3I8+vof5+38j5//e38j7mJX73PtL/hB/+xXi+UVfofYrzN+t4rn/aJytw+1n/1mc/q9f4h/8R/J93q+/le8zH3/vS/Q//AnjH+d9/+6f4x9s3NyvLzC/6GfUnPn/f/3zj/4z/XG/Vvqnx7/5MfV/8BV8D8/HM3/nK9x/8Ic4z/nq6jz34xd9Dx/7Pdy/9z38o7+Phn76/pe/j//rp3/1m9/+/k//5bebH+5PP1x+/m5/9fPTfD3Vh6fj6fF0PYWn9PR6Kk9ulBvtRrvRbrQb7Ua70W60G+1GuzFujBvjxrgxbowb48a4MW7M142f/ol5Op4eT9dTeEpPr6fy1J7cOG4cN44bx43jxnHjuHHcOG4cNx43HjceNx43HjceNx43HjceNx43rhvXjevGdeO6cd24blw3rhvXjXAj3Ag3wo1wI9wIN8KNcCPcSDfSjXQj3Ug30o10I91IN9KN143XjdeN143XjdeN143XDZ0/On90/uj80fmj80fnj84fnT86f3T+6PzR+aPzR+ePzh+dPzp/dP7o/NH5o/NH54/OH50/On90/uj80fmj80fnj86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzq/Or86vzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dB46D52HzkPnofPQeeg8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzlPnqfPUeeo8dZ46T52nzl+dvzp/df7q/NX5q/NX56/OX52/On91/ur81fmr81fnr85fnb86f3X+6vzV+avzV+evzl+dvzp/df7q/NX5q/NX56/OX52/On91/ur81fmr81fnr85fnb86f3X+6vzV+avzV+evzl+dvzp/df7q/NX5q/NX56/OX52/On91/ur81fmr81fnr85fnb86f3X+6vzV+avzV+evzl+dvzp/df7q/NX5q/NX56/OX52/On91/ur81fmr81fnr85fnb86f3X+6vzV+avzV+evzl+dvzp/df7qvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrvHXeOm+dt85b563z1nnrfHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dj85H56Pz0fnofHQ+Oh+dz1fnP/3X7R+ejqfH0/UUntLT66k8tSc3jhvHjePGceO4cdw4bhw3jhvHjceNx43HjceNx43HjceNx43HjceN68Z147px3bhuXDeuG9eN68Z1I9wIN8KNcCPcCDfCjXAj3Ag30o10I91IN9KNdCPdSDfSjXTjdeN143XjdeN143XjdeN143XjdaPcKDfKjXKj3Cg3yo1yo9woN9qNdqPdaDfajXaj3Wg32o12Y9wYN8aNcWPcGDfGjXFj3ND50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnR+dH50fnROQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDJQ+XPFzycMnDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O9PNzLw7083MvDvTzcy8O93zxcfj79fKM+n9rTfD19dv7t6Xh6PF1P4Sk9vZ7ceNx43LhuXDeuG9eNnzt/Pj6f3LhuXDeuG9eNcCPcCDfCjfDnCDfCjXAj3Ag30o104+fOv33P6Ua6kW6kG+lGupFuvG68brz+HK8brxuvG68brxuvG68bP3f+7XsuN8qNcqPcKDfKjXKj3Cg32p+j3Wg32o12o91oN9qNnzv/9j23G+PGuDFujBvjxrgxbowb488xXze+ebhvT8fT4+l6Ck/p6f3+PX/zcN/+Wnty47hx3DhuHDeOG8eN83pyQ+ePzh+dPzp/dP7o/NPDffuedf7o/NH5o/NH54/OH50/On90/s3DfXtyQ+ePzh+dPzp/dP7o/NPDffuedf7o/NH5o/NH54/OH50/On90/s3DfXtyQ+ePzh+dPzp/dP7o/NPDffuedf7o/NH5o/NH54/OH50/On90/s3DfXtyQ+ePzh+dPzp/dP7o/NPDffuedf7o/NH5o/NH54/OH50/On90/s3DfXtyQ+ePzh+dPzp/dP7o/NPDffuedf7o/NH51fnV+dX51fnV+dX5Nw/37ak8tSc3dH51fnV+df7p4T6/56vzq/Or86vzq/Or86vzq/Or8+vn+dX51fnV+dX51fnV+dX5p4f79j3r/Or86vzq/Or86vzq/Or86vz6eX51fnV+dX51fnV+dX51/unhvn3POr86vzq/Or86vzq/Or86vzq/fp5fnV+dX51fnV+dX51fnX96uG/fs86vzq/Or86vzq/Or86vzq/Or5/nV+dX51fnV+dX558e7tv393PnT34+vZ7KU3uar6efO//+dDw9nq6n8OTGuDFujBvzdePTw31/Op4eT9dTeEpPr6fy1J7cOG4cN44bx43jxnHjuHHcOG4cNx43HjceNx43Hjd+7vyez6fXU3lqT/P19HPn35+Op8fT9RSe3Lhu/Nz5fT6f3LhuhBvhxs+df3tFuBFuhBvhRrgRboQb6Ua6kW6kG+lGupFupBvpRrrxuvG68brxuvG68brxuvG68brxulFulBvlRrlRbpQb5Ua5UW6UG+1Gu9FutBvtRrvRbrQb7Ua7MW6MG+PGuDFujBvjxrgxbszXjU8P9/3pePq68enhvv+18JSeXk/lFe2vuXHcOG4cN44bx43jxnHjuHHcOG48bjxuPG48bjxu6Dx1/unhvr/CDZ2nzlPnnx7u2yt0njpPnafOU+ep89R56jx1njpPnafOU+ep89R56jx1njpPnafOU+ep89R56jx1njpPnafOU+ep89R56jx1njpPnafOU+ep89R56jx1njpPnafOU+ep89R56jx1njpPnafOU+ep808P9/3JDZ2nzlPnnx7u+5MbOv/0cN++A51/erjvT27o/NPDfb7i1fmnh/v+dD2Fp/SK118rT+3JjeOGzj893PcnN3T+6eG+v8KN44bOX51/erhvr9D5p4f7/uSGzj893PdXuOHn+avzV+efHu7bK3T++nn+6vzV+aeH+/4KN64bOn91/unhvr1C558e7vuTGzr/9HDfX+FGuKHzV+efHu7bK3T+6eG+P7mh808P9/0VbqQbOn91/unhvr1C558e7vuTGzr/9HDfX+HG64bOX51/erhvr9D5p4f7/uSGzj893PdXuFFu6PzV+aeH+/YKnX96uO9Pbuj808N9f4UbOn91/ur808N9e4XOX52/On91/ur81fmr81fnr85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L56Xz0nnpvHReOi+dl85L558e7unPp8eTGzovP89L56Xz0nnpvPw8L52XzkvnpfPSeem8dF46L52XzkvnpfPSeem8dF46L52XzkvnpfPSeem8dF46L52XzkvnpfPSeem8dF46L52XzkvnpfPSeem8dF46L52XzkvnpfPSeem8dF46L523zlvnrfPWeeu8dd46b523zlvnrfPWeeu8dd46b523zlvnrfPWeeu8dd46b523zlvnrfPWeeu8dd46b523zlvnrfPWeeu8dd46b523ztvP8/bzvHXeOm8/z1vnrfPWeeu8/TxvnbfOW+et89Z567x13jpvnbfOW+et89Z567x13jpvnbfOW+et89Z567x13jpvnbfOW+et89Z567x13jpvnbfOW+et89Z567x13jpvnbfOW+et89Z567x13jpvnY/OPz3c50+NTw/3/en63wtP6en1VJ7akxv+7/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/PR+eh8dD46H52Pzkfno/P56rw+vjqvj6+f5/Xx9fO8Pr46r4+vzuvj6+d5fXx1Xh9fndfHV+f18eHGceO4cdw4bhw3jhvHjePGceO48bjxuPG48bjxuPG48bjxuPG48bhx3bhuXDeuG9eN68Z147px3bhuhBvhRrgRboQb4Ua4EW6EG+FGupFupBvpRrqRbqQb6Ua6kW68brzff37Up4f7/uTG68bXfw9XH68brxuvG68bX/89XH2UP0f5c5Qb5Ub5c5Qb5Ua5UW60P0e70W60G+1Gu9FutBvtRrsxbowb48a4MW6MG+PGuDFu6Pzo/Oj86Pzo/Oj86Pzo/Oj86Pzo/Oj86Pzo/Oj8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XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwxcMVD1c8XPFwzcM1D9c8XPNwzcM1D9c8XPNwzcM1D9c8XPNwzcM1D9c8XPNwzcM1D9c8XPNwzcP1x9f75/3x9f5583DNw/XH1/vnzcM1D9c8XPNw/fH1/nnzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3DNQ/XPFzzcM3D9cfrxuvG68brxuvG68brxuvG60a5UW6UG+VGuVFulBvlRrlRbrQb7Ua70W60G+1Gu9FutBvtxrgxbowb48a4MW6MG+PGuKFzHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq7P1/vnfb7eP28ernm4Pl/vnzcP1zxc83DNw/X5ev+8ebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4frR+aNzHq55uH50zsM1D9c8XPNw/eich2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2seru/X++d9v94/bx6uebi+X++fNw/XPFzzcM3D9f16/7x5uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObh+ur86pyHax6ur855uObhmodrHq6vznm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uE6v94/7/x6/7x5uObh2ufDNQ/XPFzzcM3Dtc+Hax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebjm4ZqHax6uebj2+XCdOufhmofr1DkP1zxc83DNw3XqnIdrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq7fr/fP+/16/7x5uObh+v16/7x5uObhmodrHq7fr/fPm4drHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq59Plz7fLjm4ZqHa58P1zxc83DNwzUP1z4frnm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uG6vX/e3j/n4ZqH6/b+OQ/XPFzzcM3DdXv/nIdrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq55uObhmodrHq59Plz7fLjm4ZqHa58P1zxc83DNwzUP1z4frnm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uGah2sernm45uF6vH8+3j/n4ZqH6/H+OQ/XPFzzcM3D9Xj/nIdrHq55uObhmodrHq55uObhmocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm58Ptz4fLjh4YaHG58PNzzc8HDDww0PNz4fbni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eHmfL1/Pufr/fPh4YaHm/P1/vnwcMPDDQ83PNycr/fPh4cbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm58Ptz4fLjh4YaHG58PNzzc8HDDww0PNz4fbni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eHmfr1/Pvfr/fPh4YaHm/v1/vnwcMPDDQ83PNzcr/fPh4cbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm58Ptz4fLjh4YaHG58PNzzc8HDDww0PNz4fbni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eEmvt4/n/h6/3x4uOHhxv+/1OHhhocbHm54uPH/L3V4uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhxufDjc+HGx5ueLjx+XDDww0PNzzc8HDj8+GGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebt6v98/n/Xr/fHi44eHm/Xr/fHi44eGGhxsebt6v98+Hhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebnw+3Ph8uOHhhocbnw83PNzwcMPDDQ83Ph9ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4YaHGx5ueLjh4aa+3j+f+nr/fHi44eGmvt4/Hx5ueLjh4YaHm/p6/3x4uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhxufDjc+HGx5ueLjx+XDDww0PNzzc8HDj8+GGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebni44eGGhxsebsb75+P9cx5ueLgZ75/zcMPDDQ83PNyM9895uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhhocbHm54uOHhxufDjc+HGx5ueLjx+XDDww0PNzzc8HDj8+GGhxsebni44eGGhxsebni44eGGhzsfQNzPj2f/6rOPdx9jH3Nf9u5frX3sfdxrZ6+dvXb22tlrZ6+dvXb22tlrZ6+dvfbstWevPXvt2WvPXnv22rPXnr327LVnr929dvfa3Wt3r929dvfa3Wt3r929dvda7LXYa7HXYq/FXou9Fnst9lrstdhruddyr+Vey72Wey33Wu613Gu513KvvXvt3WvvXnv32rvX3r327rV3r7177d1rtddqr9Veq71We632Wu212mu112qv9V7rvdZ7rfda77Xea73Xeq/1Xuu9Nntt9trstdlrs9dmr81em702e2235OyWnK936X9+fPbx7v9u7GPu47uPtY+9j3vt6+36nx/PPj77uNd2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7Jac3ZKzW3J2S85uydktObslZ7fk7JY8uyXP/l7y7O8lz27Js1vy7O8lz27Js1vy7JY8uyXP/l7y7JY8uyXPbsmzW/Lsljy7Jc9uybNb8uyWPLslz27Js1vy7JY8uyXPbsmzW/Lsljy7Jc9uybNb8uyWPLslz27Js1vy7JY8uyXPbsmzW/Lsljy7Jc9uybNb8uyWPLslz27Js1vy7JY8uyXPbsmzW/Lsljy7Jc9uybNb8uyWPLslz27Js1vy7JY8uyXP6+fb8z77uNd2S54393Gv7ZY8uyXPbslTH/u4f7bdkme35NkteXZLnt2SZ7fk2S15dkue3ZJnt+TZLXl2S57dkme35NkteXZLnt2SZ7fk2S15dkue3ZJnt+TZLXl2S57dkme35NkteXZL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+Tultz9veTu7yV3t+Tultz9veTultzdkrtbcndL7v5ecndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3t+TultzdkrtbcndL7m7J3S25uyV3tyR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZL4vHzLZ5nH/fabkk8uY97bbckdktityTuxz7un223JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLYrckdktityR2S2K3JHZLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyT395Lc30tytyR3S3J/L8ndktwtyd2S3C3J/b0kd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyR3S3K3JHdLcrckd0tytyTbz7fsZx/32m5Jdu7jXtstyd2S3C3J+djH/bPtluRuSe6W5G5J7pbkbknuluRuybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lulry7Je9uybtb8u6WvLsl727Ju1vy7pa8uyXvbsm7W/Lu7yXv/l7y7pa8uyXv/l7y7pa8uyXvbsm7W/Lu7yXvbsm7W/Lulry7Je9uybtb8u6WvLsl725J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2W1G5J7ZbUbkntltRuSe2WVPj5VvHs417bLanIfdxruyW1W1K7JZUf+7h/tt2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktotqd2S2i2p3ZLaLandktot6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt7fS3p/L+ndkt4t6f29pHdLerekd0t6t6T395LeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLendkt4t6d2S3i3p3ZLeLZndkllfMutLZrdkdktmfcnslsxuyeyWzG7JrC+Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktmd2S2S2Z3ZLZLZndktktWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eD77kfPAlZ93rWfd6PviSs+71rHs9617PutfzwZecda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd6zm7JWe3ZN3rWfd6zm7Jutez7vWsez3rXs/ZLVn3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nocvOQ9fcta9nnWv5+FLzrrXs+71rHs9617Pw5ecda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd63l2S57dknWvZ93reXZL1r2eda9n3etZ93qe3ZJ1r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd67l8ybl8yVn3eta9nsuXnHWvZ93rWfd61r2ey5ecda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd64ndktgtWfd61r2e2C1Z93rWvZ51r2fd64ndknWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rWfd61r2eda9n3etZ93rWvZ51r2fd61n3eta9nnWvZ93rSb7kJF9yvrnX+9df/fC/f/On3//mn3/83X/88E//+dO//Ne//OG3f/79H//w/V/++f/9969/55//9Psff/z9v/363//0x9/+7l/+8qff/frHP/7289/76//66/8H","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use keccak256::keccak256;\n\nstruct UnpaiedEntry {\n    unpaied_loan_id: [u8;32],\n    unpaied_amt: [u8;32],\n}\n\nfn main(\n    loan_state:pub [[u8;32]; 32],\n    baseid: [u8;32],\n    repaid_k1: [u8;32],\n    unpaied_k1: [UnpaiedEntry; 32],\n    k1: [u8;32],\n) {\n    let mut preimage: [u8;2144] = [0u8;2144];\n\n    for i in 0..32 { preimage[i] = baseid[i]; }\n    for i in 0..32 { preimage[32 + i] = repaid_k1[i]; }\n\n    let mut offset = 64;\n    for t in 0..unpaied_k1.len() {\n        for j in 0..32 {\n            preimage[offset + j] = unpaied_k1[t].unpaied_loan_id[j];\n        }\n        offset = offset + 32;\n        for j in 0..32 {\n            preimage[offset + j] = unpaied_k1[t].unpaied_amt[j];\n        }\n        offset = offset + 32;\n    }\n\n    for i in 0..32 { preimage[offset + i] = k1[i]; }\n\n    let state_k1 = keccak256(preimage, preimage.len());\n\n    let mut flag = false;\n    for i in 0..loan_state.len() {\n        if state_k1 == loan_state[i] { flag = true; }\n    }\n    assert(flag);\n}\n","path":"/Users/maruyamashuntaira/W2P-ETHTokyo/contract/circuits/repayCircuit/src/main.nr"},"52":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/Users/maruyamashuntaira/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}